====================================================== LESSON 002 ======================================================

Когда в браузере указываем адрес, ему нужно сделать запрос на какой-то сервер, а на какой именно он узнает,
с помощью DNS-серверов.

Сервер - это какой-то компьютер, на котором стоит специальное серверное приложение, принимающее запросы от браузеров.

В ответ на запросы браузеров сервер должен догадаться что нужно браузеру, с помощью адреса.

Иногда сервера не получают точное указание, что именно им загрузить, а по дефолту загружают файл index.html, если такой
у них есть.

Если сайт был сделан на каком-то фреймворке, то скорее всего в файле index.html не будет много HTML-разметки, но будет
корневой HTML-элемент div с атрибутом id указанным как "root". При дальнейшей работе с сайтом в этот корневой
HTML-элемент div будут подгружаться остальные части сайта с сервера.

Важно декомпозировать front-end-приложение на часть, работающую с данными, и на часть, занимающуюся отрисовкой этих
данных.

Если в адресе указан "localhost", браузер обратится к компьютеру, на котором находится приложение, а не к DNS-серверам.

После "localhost" в адресе указывается порт, являющийся индивидуальным id для программы. Порт выдается каждой программе
для обмена данными, чтобы на компьютере и к компьютеру могли одновременно обращаться большое количество программ, и при
этом не тормозить друг друга.

====================================================== LESSON 003 ======================================================

Браузер является главной средой выполнения JavaScript.

Node.js это еще одна платформа для выполнения JavaScript, на которой можно делать приложения отличные от стандартных
web-приложений в браузерах.

Браузер Chrome и Node.js сделаны на движке V8.

Браузер Chrome к функционалу, который есть на движке V8, добавляет функционал для работы с DOM-деревом и браузерным API.
Node.js к функционалу, который есть на движке V8, добавляет более широкий функционал по обработке и отправке HTTP
запросов, функционал для работы с файловой системой, для выполнения внешних процессов и для взаимодействия с базами
данных.

Библиотеки, пакеты и фреймворки это универсальные инструменты, которые облегчают работу с более низкоуровневым JS.

Библиотеки, пакеты и фреймворки, от которых зависит код, называются dependencies. Современные front-end-приложения
состоят из dependencies и какого-то JavaScript кода.

Фреймворки могут диктовать свои дополнительные правила как писать код, а библиотеки просто предоставляют дополнительный
функционал.

TypeScript - это модификация JavaScript, которая дает строгую типизацию, предотвращающую разработчиков от ошибок,
подсказывая, например, какие функции можно вызывать с какими аргументами.

Транспиляция - преобразование программы, написанной на одном языке, в программу, написанную на другом языке.

Есть два вида dependencies: первые нужны для работы приложения (dependencies), а вторые нужны для разработки приложения
(dev dependencies).

Node.js нужен для разработки приложений, а не использования их.

Node.js нужен для создания и работы с библиотеками, пакетами и фреймворками.

Современные front-end-приложения создаются при помощи Node.js.

NPM (node package manager) - это инструмент для менеджмента пакетов. NPM идет вместе с установкой Node.js.

NPM состоит для NPM и NPX. NPM нужен для установки пакетов, а NPX для их запуска.

====================================================== LESSON 004 ======================================================

Vite - инструмент сборки, призванный обеспечить более быструю и эффективную разработку современных веб-проектов.

Создание приложения на Vite + React: npm create vite@latest

Файл package.json является конфигурацией описания проекта, с точки зрения Node.js.

Загрузка зависимостей из package.json: npm install

Запуск проекта: npm run dev

Компонента - это "строительный блок", из которой состоит любое React-приложение. По факту, это HTML-тэг, который может
быть обработан React-ом. Компонента, сама по себе, вызывает одноименную функцию, которую обычно называют с большой буквы
и она возвращают разметку .jsx. Компонента может возвращать только один узел.

HTML-элемент <></> называется фрагмент, он нужен, для того чтобы объединить несколько тегов вместе, не создавая
настоящий HTML-элемент.

Разметка .jsx или .tsx парсятся React-ом, а не браузером, в отличие от HTML-разметки.

Props в React - это как аргументы функций в JavaScript и атрибуты в HTML.

В TypeScript знак "!" в конце каких-то данных означает, что мы уверены, что какие-то данные не равны null или
undefined, даже если TypeScript думает, что они могут быть null.

React может распарсить массив и отрисовать его элементы сам автоматически.

====================================================== LESSON 005 ======================================================

Главное преимущество метода map() заключается в том, что несмотря на количество элементов в исходном массиве, в
итоговом массиве будет такое же количество элементов. Каждому элементу в итоговом массиве будет соответствовать элемент
с таким же индексом из исходного массива. В параметры метода map() передается callback-функция, которая вызывается для
каждого элемента массива(элементы отдаются в параметры этой функции). В параметры callback-функции метода map() отдаются
следующие три значения по порядку: элемент массива, индекс, сам массив.

Запуск JS файла в консоли: node file-name.js
В консоли будут отображаться только команды console.log().

Javascript код, который написан так, что может запускаться и в браузере и в консоли называется универсальным или
изоморфным.

====================================================== LESSON 006 ======================================================

Чтобы приложение работало корректно, требуется подключать JS файлы в index.html в том порядке, в котором они находились
бы, если подразделений на файлы не было, а вместо их был один большой JS файл.

Чтобы файл стал модулем, в html-разметке в соответствующем html-элементе необходимо указать атрибут type="module".

Для того чтобы экспортировать и импортировать файлы существуют директивы import и export.
Директива import используется вместе с ключевым словом from в следующем формате:
import [название импортируемого объекта] from [относительный путь до модуля, в котором этот объект был создан];
Под объектом тут понимается любое объявление, будь то функция, массив или любой другой тип данных.

Такому формату импорта соответствует размещение директивы export в нужном модуле, перед объявлением того, что мы хотим
экспортировать, вместе с ключевым словом default. Например:
export default function myFunction() {...};
Или уже после объявления:
export default myFunction;

Важно отметить, что default в одном модуле может использоваться только один раз.

Также, существует другой способ импортирования и экспортирования, не использующий default.
Импорт в таком случае пишется так:
import { [название импортируемого объекта] } from [относительный путь до модуля, в котором этот объект был создан];

Такому формату импорта соответствует размещение директивы export в нужном модуле, исключительно перед объявлением того,
что мы хотим экспортировать:
export default function myFunction() {...};

В любом модуле импорты всегда выполняются первыми, независимо от их расположения в файле.

При указании после директивы import только относительный путь до файла, даже при отсутствии экспортов в нем, он
запустится.

Если в импорте после названия импортируемого объекта в {} написать ключевое слово as, то после него можно написать новое
название данного объекта, под которым оно будет известно в файле, где был совершен импорт. Это используется во избежание
конфликта объектов с одинаковыми именами.

Также существует следующий формат импорта:
import * as [название] from [относительный путь до модуля, в котором этот объект был создан];
При такой записи, к символу * можно будет обращаться как к объекту в обычном JS, и его свойствами будут являться
экспорты из указанного модуля.