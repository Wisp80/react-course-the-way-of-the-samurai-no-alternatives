====================================================== LESSON 002 ======================================================

Когда в браузере указываем адрес, ему нужно сделать запрос на какой-то сервер, а на какой именно он узнает,
с помощью DNS-серверов.

Сервер - это какой-то компьютер, на котором стоит специальное серверное приложение, принимающее запросы от браузеров.

В ответ на запросы браузеров сервер должен догадаться что нужно браузеру, с помощью адреса.

Иногда сервера не получают точное указание, что именно им загрузить, а по дефолту загружают файл index.html, если такой
у них есть.

Если сайт был сделан на каком-то фреймворке, то скорее всего в файле index.html не будет много HTML-разметки, но будет
корневой HTML-элемент div с атрибутом id указанным как "root". При дальнейшей работе с сайтом в этот корневой
HTML-элемент div будут подгружаться остальные части сайта с сервера.

Важно декомпозировать front-end-приложение на часть, работающую с данными, и на часть, занимающуюся отрисовкой этих
данных.

Если в адресе указан "localhost", браузер обратится к компьютеру, на котором находится приложение, а не к DNS-серверам.

После "localhost" в адресе указывается порт, являющийся индивидуальным id для программы. Порт выдается каждой программе
для обмена данными, чтобы на компьютере и к компьютеру могли одновременно обращаться большое количество программ, и при
этом не тормозить друг друга.

====================================================== LESSON 003 ======================================================

Браузер является главной средой выполнения JavaScript.

Node.js это еще одна платформа для выполнения JavaScript, на которой можно делать приложения отличные от стандартных
web-приложений в браузерах.

Браузер Chrome и Node.js сделаны на движке V8.

Браузер Chrome к функционалу, который есть на движке V8, добавляет функционал для работы с DOM-деревом и браузерным API.
Node.js к функционалу, который есть на движке V8, добавляет более широкий функционал по обработке и отправке HTTP
запросов, функционал для работы с файловой системой, для выполнения внешних процессов и для взаимодействия с базами
данных.

Библиотеки, пакеты и фреймворки это универсальные инструменты, которые облегчают работу с более низкоуровневым JS.

Библиотеки, пакеты и фреймворки, от которых зависит код, называются dependencies. Современные front-end-приложения
состоят из dependencies и какого-то JavaScript кода.

Фреймворки могут диктовать свои дополнительные правила как писать код, а библиотеки просто предоставляют дополнительный
функционал.

TypeScript - это модификация JavaScript, которая дает строгую типизацию, предотвращающую разработчиков от ошибок,
подсказывая, например, какие функции можно вызывать с какими аргументами.

Транспиляция - преобразование программы, написанной на одном языке, в программу, написанную на другом языке.

Есть два вида dependencies: первые нужны для работы приложения (dependencies), а вторые нужны для разработки приложения
(dev dependencies).

Node.js нужен для разработки приложений, а не использования их.

Node.js нужен для создания и работы с библиотеками, пакетами и фреймворками.

Современные front-end-приложения создаются при помощи Node.js.

NPM (node package manager) - это инструмент для менеджмента пакетов. NPM идет вместе с установкой Node.js.

NPM состоит для NPM и NPX. NPM нужен для установки пакетов, а NPX для их запуска.

====================================================== LESSON 004 ======================================================

Vite - инструмент сборки, призванный обеспечить более быструю и эффективную разработку современных веб-проектов.

Создание приложения на Vite + React: npm create vite@latest

Файл package.json является конфигурацией описания проекта, с точки зрения Node.js.

Загрузка зависимостей из package.json: npm install

Запуск проекта: npm run dev

Компонент - это "строительный блок", из которой состоит любое React-приложение. По факту, это HTML-тэг, который может
быть обработан React-ом. Компонент, сам по себе, вызывает одноименную функцию, которую обычно называют с большой буквы
и она возвращают разметку .jsx. Компонент может возвращать только один узел.

HTML-элемент <></> называется фрагмент, он нужен, для того чтобы объединить несколько тегов вместе, не создавая
настоящий HTML-элемент.

Разметка .jsx или .tsx парсятся React-ом, а не браузером, в отличие от HTML-разметки.

Props в React - это как аргументы функций в JavaScript и атрибуты в HTML.

В TypeScript знак "!" в конце каких-то данных означает, что мы уверены, что какие-то данные не равны null или
undefined, даже если TypeScript думает, что они могут быть null.

React может распарсить массив и отрисовать его элементы сам автоматически.

====================================================== LESSON 005 ======================================================

Главное преимущество метода map() заключается в том, что несмотря на количество элементов в исходном массиве, в
итоговом массиве будет такое же количество элементов. Каждому элементу в итоговом массиве будет соответствовать элемент
с таким же индексом из исходного массива. В параметры метода map() передается callback-функция, которая вызывается для
каждого элемента массива(элементы отдаются в параметры этой функции). В параметры callback-функции метода map() отдаются
следующие три значения по порядку: элемент массива, индекс, сам массив.

Запуск JS файла в консоли: node file-name.js
В консоли будут отображаться только команды console.log().

Javascript код, который написан так, что может запускаться и в браузере и в консоли называется универсальным или
изоморфным.

====================================================== LESSON 006 ======================================================

Чтобы приложение работало корректно, требуется подключать JS файлы в index.html в том порядке, в котором они находились
бы, если подразделений на файлы не было, а вместо них был один большой JS файл.

Чтобы JS файл стал модулем, в html-разметке в html-элементе script необходимо указать атрибут type="module".

Для того чтобы экспортировать и импортировать файлы существуют директивы import и export.
Директива import используется вместе с ключевым словом from в следующем формате:
import [название импортируемого объекта] from [относительный путь до модуля, в котором этот объект был создан];
Под объектом тут понимается любое объявление, будь то функция, массив или любой другой тип данных.

Такому формату импорта соответствует размещение директивы export в нужном модуле, перед объявлением того, что мы хотим
экспортировать, вместе с ключевым словом default. Например:
export default function myFunction() {...};
Или уже после объявления:
export default myFunction;

Важно отметить, что default в одном модуле может использоваться только один раз.

Также, существует другой способ импортирования и экспортирования, не использующий default.
Импорт в таком случае пишется так:
import { [название импортируемого объекта] } from [относительный путь до модуля, в котором этот объект был создан];

Такому формату импорта соответствует размещение директивы export в нужном модуле, исключительно перед объявлением того,
что мы хотим экспортировать:
export default function myFunction() {...};

В любом модуле импорты всегда выполняются первыми, независимо от их расположения в файле.

При указании после директивы import только относительный путь до файла, даже при отсутствии экспортов в нем, он
запустится.

Если в импорте после названия импортируемого объекта в {} написать ключевое слово as, то после него можно написать новое
название данного объекта, под которым оно будет известно в файле, где был совершен импорт. Это используется во избежание
конфликта объектов с одинаковыми именами.

Также существует следующий формат импорта:
import * as [название] from [относительный путь до модуля, в котором этот объект был создан];
При такой записи, к символу * можно будет обращаться как к объекту в обычном JS, и его свойствами будут являться
экспорты из указанного модуля.

====================================================== LESSON 007 ======================================================

В самозакрывающихся HTML-элементах в HTML на самом деле можно не указывать слэш в конце тэга. Но в JSX необходимо писать
слэш в конце тэга.

JSX - это инструкции JavaScript по созданию объектов.

То, что называют аттрибутами в HTML, в React называют пропами. Многие пропы в React отличаются (различия могут быть как
большими, так и незначительными) от аттрибутов в HTML, например:

Некоторые аттрибуты в HTML, например, disabled, не нуждаются в присваивании им какого-либо значения, однако это
можно сделать. Они работают уже просто при наличии. В JSX же подобным пропам нужно отдавать булевое значение.

Проп style в JSX нельзя писать строкой, как в HTML. Вместо этого туда требуется передавать объект со свойствами из
CSS, написаные верблюжим стилем.

Аттрибут class в HTML, в JSX реалезуется пропом className, которому в параметры нужно отдать ту же самую строку с
названием класса, что и в HTML. Если хотим присвоить одному элементу много классов, то тоже перечесляем классы через
пробел, как и в HTML.

====================================================== LESSON 008 ======================================================

Нормализация данных - это метод работы с данными, при котором данные хранятся в одном месте, а при нужде использования
этих данных, они находятся с помощью идентификатора, вместо создания копии этих данных.

====================================================== LESSON 009 ======================================================

Хуки - это специальные функции, предаставленные React.

Хук UseState() возвращает массив, в котором нулевой элемент это значение, положенное в параматры UseState() изначально,
а второе это функция, которая при вызове положит новое значение, указанное в параметрах, в UseState().

Сеттер в хуке "useState()" планирует перерисовку компонента, во время которой будет произведено обновление каких-то
отслеживаемых данных.

Лучше всего писать хук UseState(), с помощью деструктурирующего присваивания, таким образом:
const idManagenment = useState(null);
const [id, setId] = idManagenment;
Это помогает улучшить читаемость кода.

React перерисовывает компонент только в ответ на изменение каких-то отслеживаемых им данных.

Перерисовка компонента осуществляется путем вызова функции, описывающей этот компонент.

====================================================== LESSON 010 ======================================================

Swagger - это приложение, с помощью которого можно узнать спецификации к работе с бэк-эндом, а также делать тестовые
запросы на этот бэк-энд.

Некоторые запросы на определенный бэк-энд могут требовать API-key.

====================================================== LESSON 011 ======================================================

При любом очередном вызове компонента, количество и порядок хуков не должны меняться.

Количество вызовов хуков должно соответствовать количеству перерисовок компонента. Поэтому хуки нельзя указывать в
условных конструкциях.

"Рендер" в контексте React подразумевает вызов компонента и JSX-разметку, которую возвращает этот компонент.

Рендер делится на две фазы: первый запуск компонента(монтирование) и все последующие обновления компонента.

React, когда отрисовывает компонент, хранит информацию о нем в узле, называемом FiberNode.

Хук UseEffect() первым параметром принимает асинхронную callback-функцию, а вторым массив зависимостей. Чтобы после
изначальной отрисовки компонента, в котором содержится хук UseEffect(), переданная туда callback-функция вызвалась
только один раз, необходимо вторым параметром передать пустой массив.

Жизненный цикл монтирования функционального компонента (Lifecycle Mount Mode):
1. Создание объекта типа FiberNode для хранения локального состояния компонента.
2. Render Phase: первая отрисовка компонента путем вызова функции компонента.
3. Заполнение объекта типа FiberNode на основе используемых хуков, props и локального состояния в компоненте.
4. Возвращение JSX в виде объекта типа "React Element".
5. Commit Phase: фиксирование актуальных DOM-элементов на основе возвращенного JSX при помощи низкоуровневых устройств
JS для работы с DOM-деревом.
6. Визуализация актуального DOM-дерева в браузере.
7. Effects Phase: Выполнение эффектов.

Жизненный цикл обновления функционального компонента (Lifecycle Update Mode) при изменении локального состояния
компонента:
1. Render Phase: отрисовка компонента путем вызова функции компонента.
2. Заполнение объекта типа FiberNode на основе используемых хуков, props и локального состояния в компоненте.
3. Возвращение JSX в виде объекта типа "React Element".
4. Commit Phase: фиксирование актуальных DOM-элементов на основе возвращенного JSX при помощи низкоуровневых устройств
JS для работы с DOM-деревом.
5. Cleanup Phase: удаление старых неактуальных эффектов из объекта типа FiberNode.
6. Визуализация актуального DOM-дерева в браузере.
7. Effects Phase: Выполнение эффектов.

Жизненный цикл демонтирования функционального компонента (Lifecycle Unmount Mode):
1. Cleanup Phase: удаление эффектов из объекта типа FiberNode.
2. Remove from DOM Phase: удаление DOM-элементов из DOM-дерева.
3. Визуализация актуального DOM-дерева в браузере.

====================================================== LESSON 012 ======================================================

Метод filter() вызывается у массивов через точку и принимает один параметр: callback-функцию, которую также называют
предикатом. Предикат возвращает только true или false. Если предикат возвращает true, то элемент массива, для которого
вызывался предикат, будет в новом массиве, созданном filter(). Если предикат возвращает true, то соответсвующий элемент
не будет в новом массиве.

Метод find() вызывается у массивов через точку и принимает один параметр, который тоже является предикатом. Метод find()
возвращает только один элемент из массива, для которого предикат вернет true первым. Сколько бы валидных для предиката
элементов в массиве не было, find() всегда вернет только один. Если в массиве нет элементов, валидных для предиката,
то find() вернет undefind.

Предикат в обоих методах принимает три параметра: текущий элемент массива, индекс итерации и сам массив.

Сложность алгоритма O(n) - линейная. Это означает, что чем больше элементов, над которыми производится алгоритм, тем
пропорционально дольше времени будет занимать работа алгоритма.

====================================================== LESSON 014 ======================================================

Если в команде для запуска JS файла с помощью Node.js, указать флаг --watch, то терминал будет автоматически
перезапускать файл после каждого изменения.

Некоторые типы данных в JS могут возвращать псевдоправду (truthy) или псевдоложь (falsy). Например, псевдоправду
возвращают: непустая строка, объект, массив, функция, число(кроме нуля), свойство length непустого массива и т.д.
Например, псевдоложь возвращают: 0, null, undefind, NaN, пустая строка.

Конвертировать в булевый тип данных можно также с помощью написания !!, перед объектом конвертации или поместить его в
качестве параметра функции Boolean().

Оператор && выполняет следующие действия:
1. Вычисляет операнды слева направо.
2. Каждый операнд конвертирует в логическое значение. Если результат false, останавливается и возвращает исходное
значение этого операнда.
3. Если все операнды являются истинными (true), возвращает последний из них.

Оператор || выполняет следующие действия:
1. Вычисляет операнды слева направо.
2. Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное
значение этого операнда.
3. Если все операнды являются ложными (false), то возвращает последний из них.

====================================================== LESSON 015 ======================================================

UseEffect синхронизирует программу с внешним миром. React решает, когда выполнить эффект.

Если хуку UseEffect() в параметры(зависимости) ничего не передать, то этот UseEffect() будет выполняться после каждого
рендера.

Если хуку UseEffect() в параметры(зависимости) передать пустой массив или массив с константой, то этот UseEffect() будет
выполняться только при первом рендере.

Если хуку UseEffect() в параметры(зависимости) передать массив с неким содержанием, то этот UseEffect() будет
выполняться только тогда, когда массив зависимостей изменяется.

Количество элементов в массиве зависимостей хука UseEffect() всегда должно быть одинаковым.

Callback-функцию, которая передается хуку UseEffect(), можно называть эффект или сетап.

Лучше делать запросы на другой сервер в момент обработки события (например, клика), вместо создания отдельного хука
useEffect().

====================================================== LESSON 016 ======================================================

Декомпозирование кода на компоненты упрощает чтение и поддержку проекта. Когда код разделён на компоненты, структура
приложения становится прозрачнее, легче находить нужные части и вносить изменения, не усложняя остальную кодовую базу.